<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Killer Darts Scorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="manifest" href="killer_manifest.json">
    <meta name="theme-color" content="#4A1D1F">
    <link rel="apple-touch-icon" href="killer_icon-192x192.png">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
            background-color: #1a202c; /* A dark slate color */
        }
        .player-card {
            transition: all 0.3s ease-in-out;
            border: 2px solid transparent;
        }
        .player-card.is-killer {
            background-color: #4A1D1F; /* Dark red */
            border-color: #F87171; /* Lighter red */
            box-shadow: 0 0 15px rgba(248, 113, 113, 0.5);
        }
        .player-card.eliminated {
            opacity: 0.5;
            background-color: #2d3748;
        }
        .current-player-turn {
            border: 2px solid #FBBF24; /* Amber */
            transform: scale(1.02);
        }
        .life {
            color: #ef4444; /* Red-600 */
        }
        .btn:disabled {
            background-color: #4a5568;
            cursor: not-allowed;
        }
        .btn:active:not(:disabled) {
            transform: scale(0.95);
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
</head>
<body class="text-white min-h-screen flex flex-col items-center p-4">

    <div id="clear-storage-btn" class="fixed top-4 left-4 z-50 bg-red-600 hover:bg-red-700 p-2 rounded-full shadow-lg cursor-pointer transition-transform hover:scale-110" title="Return to BarDarts.html">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
        </svg>
    </div>
    
    <div id="app" class="w-full max-w-5xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-bold text-red-400">Killer Darts</h1>
            <p id="game-phase-subtitle" class="text-slate-400 mt-1">Be the last one standing.</p>
        </header>

        <!-- Player Setup Section -->
        <div id="player-setup" class="bg-slate-800 p-6 rounded-lg shadow-lg mb-6">
            <h2 class="text-2xl font-semibold mb-4">Add Players</h2>
            <div id="player-list" class="flex flex-wrap gap-4 mb-4"></div>
            <div class="flex gap-4">
                <input type="text" id="new-player-name" class="flex-grow bg-slate-700 border border-slate-600 rounded-md px-3 py-2 text-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-red-400" placeholder="Enter player name...">
                <button id="add-player-btn" class="btn bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-md transition-transform">Add Player</button>
            </div>
            <div class="mt-6 flex flex-col sm:flex-row gap-3">
                <button id="start-game-btn" class="btn bg-amber-500 hover:bg-amber-600 text-slate-900 font-bold py-2 px-6 rounded-md transition-transform w-full sm:w-auto flex-grow" disabled>Start Game</button>
                <button id="reset-data-btn" class="btn bg-slate-600 hover:bg-slate-500 text-white font-bold py-2 px-4 rounded-md transition-transform w-full sm:w-auto">Reset & Clear Data</button>
            </div>
        </div>
        
        <!-- Set Target Section -->
        <div id="set-target-section" class="hidden bg-slate-800 p-6 rounded-lg shadow-lg mb-6 text-center">
            <h2 id="set-target-title" class="text-2xl font-bold mb-2">Set Initial Target</h2>
            <p class="mb-4 text-slate-300"><span id="target-setter-name" class="font-bold text-amber-300"></span>, set the target segment.</p>
            <div id="target-selection-grid" class="mt-4 text-left max-h-[60vh] overflow-y-auto">
                <!-- Buttons will be generated by JS here -->
            </div>
        </div>

        <!-- Game Section -->
        <div id="game-section" class="hidden">
            <!-- Game Controls -->
            <div id="game-controls" class="bg-slate-800 p-4 rounded-lg shadow-lg mb-6 text-center">
                <h2 class="text-2xl font-bold mb-2"><span id="turn-player-name" class="text-amber-300"></span>'s Turn</h2>
                <p class="text-5xl text-slate-300">Current Target: <span id="current-target-display" class="font-bold text-yellow-300"></span></p>
                <div id="action-buttons" class="mt-4 grid grid-cols-1 sm:grid-cols-2 gap-3">
                     <button id="became-killer-btn" class="btn bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-md transition-transform">Hit Target & Became Killer</button>
                     <button id="failed-turn-btn" class="btn bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-md transition-transform">Failed to Hit Target (-1 Life)</button>
                </div>
            </div>
            
            <!-- Player Status Grid -->
            <div id="player-status-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <!-- Player cards will be generated here -->
            </div>
        </div>
    </div>
    
    <div id="winner-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4">
        <div class="bg-slate-700 rounded-lg shadow-xl p-8 text-center max-w-sm w-full">
            <h2 class="text-3xl font-bold text-amber-300 mb-4">Game Over!</h2>
            <p id="winner-message" class="text-xl mb-6"></p>
            <button id="new-game-btn" class="btn bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-md transition-colors w-full">Play Again</button>
        </div>
    </div>

    <!-- Confirm Clear Modal -->
    <div id="confirm-clear-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
        <div class="bg-slate-800 rounded-lg shadow-xl p-8 text-center max-w-sm w-full">
            <h2 class="text-2xl font-bold text-yellow-300 mb-4">Leave Game?</h2>
            <p class="text-slate-300 mb-6">This will clear the current game's data and return you to the main screen. This action cannot be undone.</p>
            <div class="flex justify-center gap-4">
                <button id="cancel-clear-btn" class="btn bg-slate-600 hover:bg-slate-500 text-white font-bold py-2 px-6 rounded-md w-full">Cancel</button>
                <button id="confirm-clear-action-btn" class="btn bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-md w-full">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- STATE MANAGEMENT & PERSISTENCE ---
            const STORAGE_KEY = 'killerDartsGameState';

            const getInitialState = () => ({
                players: [], // { name: string, lives: int }
                gamePhase: 'setup', // 'setup', 'set_initial_target', 'set_new_target', 'playing', 'over'
                currentPlayerIndex: 0,
                killerPlayerIndex: 0,
                currentTarget: null,
                targetSelection: {
                    step: 'number', // 'number', 'multiplier'
                    number: null,
                },
            });

            const saveState = () => {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(gameState));
                } catch (e) {
                    console.error("Failed to save state to localStorage", e);
                }
            };

            const loadState = () => {
                try {
                    const savedState = localStorage.getItem(STORAGE_KEY);
                    return savedState ? JSON.parse(savedState) : getInitialState();
                } catch (e) {
                    console.error("Failed to load state from localStorage", e);
                    return getInitialState();
                }
            };

            let gameState = loadState();

            // --- DOM ELEMENTS ---
            const clearStorageBtn = document.getElementById('clear-storage-btn');
            const subtitleEl = document.getElementById('game-phase-subtitle');
            const playerSetupEl = document.getElementById('player-setup');
            const addPlayerBtn = document.getElementById('add-player-btn');
            const newPlayerNameInput = document.getElementById('new-player-name');
            const playerListEl = document.getElementById('player-list');
            const startGameBtn = document.getElementById('start-game-btn');
            const resetDataBtn = document.getElementById('reset-data-btn');
            
            const setTargetSectionEl = document.getElementById('set-target-section');
            const setTargetTitleEl = document.getElementById('set-target-title');
            const targetSetterNameEl = document.getElementById('target-setter-name');
            const targetSelectionGridEl = document.getElementById('target-selection-grid');

            const gameSectionEl = document.getElementById('game-section');
            const turnPlayerNameEl = document.getElementById('turn-player-name');
            const currentTargetDisplayEl = document.getElementById('current-target-display');
            const playerStatusGridEl = document.getElementById('player-status-grid');
            
            const becameKillerBtn = document.getElementById('became-killer-btn');
            const failedTurnBtn = document.getElementById('failed-turn-btn');
            
            const winnerModal = document.getElementById('winner-modal');
            const winnerMessage = document.getElementById('winner-message');
            const newGameBtn = document.getElementById('new-game-btn');
            const confirmClearModal = document.getElementById('confirm-clear-modal');
            const cancelClearBtn = document.getElementById('cancel-clear-btn');
            const confirmClearActionBtn = document.getElementById('confirm-clear-action-btn');

            // --- RENDER FUNCTIONS ---
            const render = () => {
                playerSetupEl.classList.add('hidden');
                setTargetSectionEl.classList.add('hidden');
                gameSectionEl.classList.add('hidden');
                
                switch (gameState.gamePhase) {
                    case 'setup':
                        subtitleEl.textContent = 'Add at least 2 players to begin.';
                        playerSetupEl.classList.remove('hidden');
                        renderPlayerSetupList();
                        break;
                    case 'set_initial_target':
                    case 'set_new_target':
                        subtitleEl.textContent = 'A new challenger sets the target...';
                        setTargetSectionEl.classList.remove('hidden');
                        renderSetTarget();
                        break;
                    case 'playing':
                        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                        subtitleEl.textContent = `Current Killer: ${gameState.players[gameState.killerPlayerIndex].name}`;
                        gameSectionEl.classList.remove('hidden');
                        renderGameboard();
                        break;
                    case 'over':
                        subtitleEl.textContent = 'The battle is done!';
                        gameSectionEl.classList.remove('hidden');
                        renderGameboard(); // Show final board
                        break;
                }
            };

            const renderPlayerSetupList = () => {
                playerListEl.innerHTML = '';
                gameState.players.forEach((player, index) => {
                    const playerTag = document.createElement('div');
                    playerTag.className = 'bg-slate-700 rounded-full px-4 py-2 flex items-center gap-3';
                    playerTag.innerHTML = `
                        <span class="font-semibold">${player.name}</span>
                        <button data-index="${index}" class="remove-player-btn text-red-400 hover:text-red-600 font-bold">X</button>
                    `;
                    playerListEl.appendChild(playerTag);
                });
                startGameBtn.disabled = gameState.players.length < 2;
            };

            const renderSetTarget = () => {
                const setterIndex = gameState.gamePhase === 'set_initial_target' ? 0 : gameState.killerPlayerIndex;
                const setter = gameState.players[setterIndex];
                setTargetTitleEl.textContent = gameState.gamePhase === 'set_initial_target' ? 'Set Initial Target' : 'Set NEW Target';
                targetSetterNameEl.textContent = setter.name;
                
                targetSelectionGridEl.innerHTML = ''; // Clear previous buttons

                if (gameState.targetSelection.step === 'number') {
                    renderNumberSelection();
                } else {
                    renderMultiplierSelection();
                }
            };

            const renderNumberSelection = () => {
                targetSelectionGridEl.innerHTML = ``;
                const createSection = (title, elements, gridCols = 'sm:grid-cols-10') => {
                    const sectionEl = document.createElement('div');
                    sectionEl.className = 'mb-4';
                    sectionEl.innerHTML = `<h3 class="text-lg font-semibold text-amber-300 mb-2">${title}</h3>`;
                    const gridEl = document.createElement('div');
                    gridEl.className = `grid grid-cols-7 ${gridCols} gap-2`;
                    elements.forEach(el => gridEl.appendChild(el));
                    sectionEl.appendChild(gridEl);
                    return sectionEl;
                };

                const numberButtons = Array.from({length: 20}, (_, i) => {
                    const num = 20 - i;
                    const btn = document.createElement('button');
                    btn.className = 'btn bg-slate-600 hover:bg-slate-500 rounded-md p-2 text-sm sm:text-base font-bold aspect-square flex items-center justify-center transition-transform text-center';
                    btn.dataset.number = num;
                    btn.textContent = num;
                    return btn;
                });
                targetSelectionGridEl.appendChild(createSection('Numbers', numberButtons));

                const bullButtons = [];
                const sbBtn = document.createElement('button');
                sbBtn.className = 'btn bg-slate-600 hover:bg-slate-500 rounded-md p-2 text-sm sm:text-base font-bold flex items-center justify-center transition-transform text-center';
                sbBtn.dataset.bull = 'SB';
                sbBtn.textContent = 'Single Bull';
                bullButtons.push(sbBtn);

                const dbBtn = document.createElement('button');
                dbBtn.className = 'btn bg-red-600 hover:bg-red-700 rounded-md p-2 text-sm sm:text-base font-bold flex items-center justify-center transition-transform text-center';
                dbBtn.dataset.bull = 'DB';
                dbBtn.textContent = 'Double Bull';
                bullButtons.push(dbBtn);

                targetSelectionGridEl.appendChild(createSection('Bullseye', bullButtons, 'grid-cols-2'));
            };

            const renderMultiplierSelection = () => {
                const selectedNum = gameState.targetSelection.number;
                targetSelectionGridEl.innerHTML = '';

                const header = document.createElement('div');
                header.className = 'flex justify-between items-center mb-4';
                header.innerHTML = `<h3 class="text-lg font-semibold text-amber-300">Select Type for <span class="text-white text-2xl">${selectedNum}</span></h3>`;
                
                const backBtn = document.createElement('button');
                backBtn.className = 'btn bg-slate-500 hover:bg-slate-400 text-slate-900 font-bold py-2 px-4 rounded-md transition-transform';
                backBtn.dataset.action = 'back';
                backBtn.textContent = '← Back';
                header.appendChild(backBtn);
                targetSelectionGridEl.appendChild(header);

                const grid = document.createElement('div');
                grid.className = 'grid grid-cols-2 sm:grid-cols-3 gap-3';
                targetSelectionGridEl.appendChild(grid);

                const multipliers = {
                    'T': { label: 'Triple', style: 'border-red-500 text-red-400'},
                    'D': { label: 'Double', style: 'border-green-500 text-green-400'},
                    'S': { label: 'Single (Skinny)', style: 'border-slate-500 text-slate-300'},
                    'F': { label: 'Single (Fat)', style: 'border-slate-500 text-slate-300'},
                };

                Object.entries(multipliers).forEach(([key, val]) => {
                    const btn = document.createElement('button');
                    btn.className = `btn bg-slate-700 hover:bg-slate-600 rounded-md p-4 text-base sm:text-lg font-bold transition-transform text-center border-2 ${val.style}`;
                    btn.dataset.multiplier = key;
                    btn.textContent = val.label;
                    grid.appendChild(btn);
                });

                const NipTargets = {
                    4: ['N'], 6: ['N'], 8: ['N Inner', 'N Outer'], 9: ['N'], 10: ['N'], 14: ['N'], 16: ['N'], 18: ['N Inner', 'N Outer'], 19: ['N'], 20: ['N']
                };

                if (NipTargets[selectedNum]) {
                    NipTargets[selectedNum].forEach(nType => {
                         const btn = document.createElement('button');
                         btn.className = 'btn bg-slate-700 hover:bg-slate-600 rounded-md p-4 text-base sm:text-lg font-bold transition-transform text-center border-2 border-sky-500 text-sky-400';
                         btn.dataset.multiplier = nType;
                         btn.textContent = nType === 'N' ? '(.)' : `(.) (${nType.split(' ')[1]})`;
                         grid.appendChild(btn);
                    });
                }
            };

            const renderGameboard = () => {
                playerStatusGridEl.innerHTML = '';
                gameState.players.forEach((player, index) => {
                    const card = document.createElement('div');
                    card.className = 'player-card bg-slate-700 p-4 rounded-lg shadow-md flex flex-col items-center';
                    if (index === gameState.killerPlayerIndex) card.classList.add('is-killer');
                    if (player.lives <= 0) card.classList.add('eliminated');
                    if (gameState.gamePhase === 'playing' && index === gameState.currentPlayerIndex) {
                        card.classList.add('current-player-turn');
                    }

                    const livesHTML = Array(5).fill(0).map((_, i) =>
                        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-7 h-7 ${i < player.lives ? 'life' : 'text-slate-600'}">
                          <path d="M11.645 20.91a.75.75 0 0 1-1.29 0C8.633 16.53 3.75 12.25 3.75 8.25 3.75 5.58 5.58 3.75 8.25 3.75c1.74 0 3.32.81 4.25 2.08 1.03-1.27 2.51-2.08 4.25-2.08 2.67 0 4.5 1.83 4.5 4.5 0 4-4.883 8.28-6.605 12.66Z" />
                        </svg>`).join('');

                    card.innerHTML = `
                        <div class="flex items-center justify-between w-full">
                           <span class="text-xl font-bold">${player.name}</span>
                        </div>
                        <div class="text-base font-semibold mt-2">${index === gameState.killerPlayerIndex ? 'KILLER' : 'Hunter'}</div>
                        <div class="flex gap-1 mt-3">${livesHTML}</div>
                    `;
                    playerStatusGridEl.appendChild(card);
                });

                if (gameState.gamePhase === 'playing') {
                    const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                    turnPlayerNameEl.textContent = currentPlayer.name;
                    currentTargetDisplayEl.textContent = gameState.currentTarget;
                    const isKiller = gameState.currentPlayerIndex === gameState.killerPlayerIndex;
                    document.getElementById('action-buttons').classList.toggle('hidden', isKiller);
                }
            };

            // --- GAME LOGIC ---
            const addPlayer = () => {
                const name = newPlayerNameInput.value.trim();
                if (name && gameState.gamePhase === 'setup') {
                    gameState.players.push({ name, lives: 5 });
                    newPlayerNameInput.value = '';
                    saveState();
                    render();
                }
            };

            const removePlayer = (index) => {
                if (gameState.gamePhase === 'setup') {
                    gameState.players.splice(index, 1);
                    saveState();
                    render();
                }
            };
            
            const selectTarget = (target) => {
                gameState.currentTarget = target;
                gameState.gamePhase = 'playing';
                gameState.targetSelection = { step: 'number', number: null }; // Reset for next time
                nextTurn(false); // don't save here, will be saved below
                saveState();
                render();
            };

            const nextTurn = (shouldSave = true) => {
                let nextIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                let loops = 0; // safety break
                while (gameState.players[nextIndex].lives <= 0 && loops < gameState.players.length) {
                    nextIndex = (nextIndex + 1) % gameState.players.length;
                    loops++;
                }
                gameState.currentPlayerIndex = nextIndex;

                const playersWithLives = gameState.players.filter(p => p.lives > 0);
                if (playersWithLives.length <= 1) {
                    endGame();
                } else {
                    if (gameState.currentPlayerIndex === gameState.killerPlayerIndex) {
                        nextTurn(false); // Recursively find the next non-killer player
                        return;
                    }
                    if (shouldSave) saveState();
                    render();
                }
            };

            const handleBecameKiller = () => {
                gameState.killerPlayerIndex = gameState.currentPlayerIndex;
                gameState.gamePhase = 'set_new_target';
                saveState();
                render();
            };

            const handleFailedTurn = () => {
                const player = gameState.players[gameState.currentPlayerIndex];
                player.lives--;
                if (player.lives <= 0) {
                    const playersWithLives = gameState.players.filter(p => p.lives > 0);
                    if (playersWithLives.length <= 1) {
                        endGame();
                        return;
                    }
                }
                nextTurn();
            };

            const endGame = () => {
                gameState.gamePhase = 'over';
                document.getElementById('game-controls').classList.add('hidden');
                const winner = gameState.players.find(p => p.lives > 0);
                winnerMessage.textContent = winner ? `${winner.name} is the Killer Champion!` : "It's a draw!";
                winnerModal.classList.remove('hidden');
                saveState();
                render();
            };
            
            const newGame = () => {
                // Keep players, reset scores and state
                gameState.players.forEach(p => p.lives = 5);
                gameState.gamePhase = 'set_initial_target';
                gameState.currentPlayerIndex = 0;
                gameState.killerPlayerIndex = 0;
                gameState.currentTarget = null;
                gameState.targetSelection = { step: 'number', number: null };
                winnerModal.classList.add('hidden');
                document.getElementById('action-buttons').classList.remove('hidden');
                saveState();
                render();
            };

            const resetAndClearData = () => {
                gameState = getInitialState();
                saveState();
                render();
            }

            // --- EVENT LISTENERS ---
            addPlayerBtn.addEventListener('click', addPlayer);
            newPlayerNameInput.addEventListener('keypress', e => e.key === 'Enter' && addPlayer());
            playerListEl.addEventListener('click', e => {
                if (e.target.classList.contains('remove-player-btn')) {
                    removePlayer(parseInt(e.target.dataset.index, 10));
                }
            });

            startGameBtn.addEventListener('click', () => {
                gameState.gamePhase = 'set_initial_target';
                gameState.killerPlayerIndex = 0;
                gameState.currentPlayerIndex = 0;
                gameState.targetSelection = { step: 'number', number: null };
                saveState();
                render();
            });

            targetSelectionGridEl.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (!button) return;

                const { number, bull, multiplier, action } = button.dataset;

                if (action === 'back') {
                    gameState.targetSelection.step = 'number';
                    gameState.targetSelection.number = null;
                    saveState();
                    renderSetTarget();
                    return;
                }
                
                if (bull) {
                    selectTarget(bull);
                    return;
                }

                if (number) {
                    gameState.targetSelection.step = 'multiplier';
                    gameState.targetSelection.number = number;
                    saveState();
                    renderSetTarget();
                    return;
                }

                if (multiplier) {
                    const num = gameState.targetSelection.number;
                    let target;
                    if (multiplier.startsWith('N')) {
                         if (multiplier.includes(' ')) {
                             target = `N${num} ${multiplier.split(' ')[1]}`;
                         } else {
                             target = `N${num}`;
                         }
                    } else {
                        target = `${multiplier}${num}`;
                    }
                    selectTarget(target);
                }
            });

            becameKillerBtn.addEventListener('click', handleBecameKiller);
            failedTurnBtn.addEventListener('click', handleFailedTurn);
            newGameBtn.addEventListener('click', newGame);

            // Modal Logic
            let onConfirmAction = null;

            const showConfirmModal = (action) => {
                onConfirmAction = action;
                confirmClearModal.classList.remove('hidden');
            };

            const hideConfirmModal = () => {
                onConfirmAction = null;
                confirmClearModal.classList.add('hidden');
            };

            confirmClearActionBtn.addEventListener('click', () => {
                if (typeof onConfirmAction === 'function') {
                    onConfirmAction();
                }
                hideConfirmModal();
            });

            cancelClearBtn.addEventListener('click', hideConfirmModal);

            resetDataBtn.addEventListener('click', () => {
                showConfirmModal(() => {
                    resetAndClearData();
                });
            });

            clearStorageBtn.addEventListener('click', () => {
                showConfirmModal(() => {
                    resetAndClearData();
                    window.location.href = 'BarDarts.html';
                });
            });

            // Initial Render on Load
            render();
        });
    </script>
</body>
</html>



